# Overview

This project is an inventory management and recipe costing system designed for food service businesses. Its primary goal is to boost profitability and operational efficiency through precise unit conversions, nested recipe management, integration with POS sales data, and detailed variance reporting. The system aims to minimize waste, optimize profit margins, provide real-time inventory estimates, streamline vendor management, and offer powerful purchasing tools to control food costs and improve overall kitchen and financial performance.

# User Preferences

- Preferred communication style: Simple, everyday language.
- Default Unit of Measure for Inventory Items: Pound should be the default unit when creating new inventory items.
- Unit Abbreviation: "Pound" displays as "lb." throughout the UI.
- Yield Field: Yield is stored as a percentage value (0-100).
- Par Level & Reorder Level: Stored on `inventory_items` table as default values, overrideable at the store level.
- Active/Inactive Status: Dual-level active status (global and store-specific).
- Store Locations: Inventory items require assignment to at least one store location during creation.
- Storage Locations: Inventory items can be associated with multiple storage locations; at least one is required. Storage Locations page features drag-and-drop reordering. Inventory count displays respect storage location sortOrder.
- Recipe `canBeIngredient`: Recipes include a `canBeIngredient` checkbox field (0/1 in DB) to mark if they can be used as ingredients in other recipes.
- Category Filtering in Recipe Builder: Categories include a `showAsIngredient` field (0/1 in DB) controlling whether items in this category appear in the recipe builder's ingredient selection.
- Recipe Cost Calculation Fix: Ingredient prices must be converted to base unit prices before multiplication.
- Recipe Company Isolation: Implement comprehensive company-level isolation for recipes and recipe components.
- Recipe Cost Recalculation on Inventory Price Changes: Automatically recalculate all affected recipes when an inventory item's price changes, including nested recipes, ensuring recalculation in dependency order.
- Number Input Fields: All number input fields throughout the application have spinner controls (up/down arrows) removed.
- Recipe Name Capitalization: Recipe names are automatically displayed with the first letter capitalized in all UI presentations while preserving the original database values.
- Placeholder Recipe System: During CSV menu import onboarding, placeholder recipes are automatically created for all recipe items (isRecipeItem=1), containing 1 oz of a "Placeholder Ingredient" and flagged with `isPlaceholder=1`. Menu Items page displays recipe status badges (Placeholder/Complete/Needs Recipe/N/A). Recipe saves set `isPlaceholder` to 0, converting placeholders to complete recipes. Recipe saves trigger Menu Items page refresh to ensure badge status and recipe costs update immediately.
- Menu Item Management: Menu items can be created manually via "Add Menu Item" dialog with form validation (required: name, PLU/SKU; optional: department, category, size, price, recipe, isRecipeItem flag). Recipe selection dropdown allows linking recipes during creation or editing. "Create new recipe with this name" link navigates to Recipe Builder with menu item name pre-populated. Menu items can be edited by clicking the item name or via the actions dropdown menu. Edit dialog includes all fields plus price and recipe selection. Active/inactive status toggle via dropdown actions menu. Department, category, and type filters (Recipe Item/Non-Recipe Item/All) enable easy sorting and filtering. Table displays Recipe Cost (computed from recipe) and Price columns, with Status and Type columns removed for cleaner UI. SKU cleanup script automatically removes pipe symbols from imported POS data and generates abbreviated SKUs (max 10 characters) from item names, with sequential numbering for duplicates.
- Menu Item Store Assignment: Menu items require assignment to at least one store during creation and editing, matching inventory items pattern. Store checkboxes appear in both Add and Edit dialogs with validation.
- Recipe Cost Display: Menu Items page displays computed recipe costs for all menu items that have recipes assigned, including both placeholder and complete recipes. Items without recipes show "-" in the Recipe Cost column.
- Dual Pricing Model: Inventory items track both Last Cost (pricePerUnit - most recent purchase price) and Weighted Average Cost (avgCostPerUnit - WAC calculated across all receipts). Inventory Items page displays both price columns. WAC is calculated during receiving using company-wide quantities: `((totalCompanyQty * currentAvgCost) + (receivedQty * received * receivedPrice)) / (totalCompanyQty + qty))`.
- Vendor Price Comparison: Purchase order creation includes a "Compare Prices" button (TrendingDown icon) on each item row that opens a dialog showing all vendor prices for an item. The dialog displays vendor name, SKU, case size, unit price, and case price, sorted by case price (lowest first). The lowest-priced vendor is highlighted with a "Best Price" badge. Uses vendor-specific case sizes and includes zero-priced items (promotional offers). Only excludes vendors with null/undefined prices.
- Vendor-Specific Purchase Order Pricing: Purchase orders use vendor-specific pricing (vendor_items.lastPrice) instead of general inventory pricing (inventory_items.pricePerUnit). All pricing logic uses nullish coalescing (`??`) to preserve legitimate zero-priced vendor items while falling back to inventory pricing only when null/undefined.
- Vendor Delivery Scheduling: Delivery scheduling is managed at the vendor level. Each vendor has `deliveryDays` (array of weekdays when vendor delivers) and `leadDaysAhead` (number of days before delivery that orders must be placed). Vendors page includes checkboxes for each weekday and a numeric input for lead days ahead in the add/edit vendor dialog. Lead time field has been completely removed from vendor items.
- Vendor Deletion Constraints: Vendors with purchase orders or vendor items (products) cannot be deleted - only deactivated. Backend enforces constraints returning 400 errors with guidance to deactivate instead. Frontend displays error messages via toast notifications.
- Misc Grocery Vendor Protection: "Misc Grocery" is a system vendor automatically created for each company. Frontend hides delete button for vendors with names containing "misc grocery" (case-insensitive). Backend additionally blocks deletion attempts via API.
- Vendor Compliance Fields: Vendors table includes compliance and accounting fields to support expense gateway functionality when products are received. Fields include: `active` (integer 0/1, default 1) for vendor status, `taxId` (text) for Tax ID/EIN, `requires1099` (integer 0/1, default 0) for 1099 reporting requirements, `paymentTerms` (text) for payment terms (e.g., "Net 30", "COD"), `creditLimit` (real) for maximum credit limit, and `certifications` (text array) for vendor certifications (e.g., Organic, Kosher, Halal). Vendors page add/edit dialog includes "Compliance & Accounting" section with all fields. QuickBooks vendor mapping automatically filters to show only active vendors (active = 1).
- Vendor Order Guide CSV Import: Vendors page includes "Import Order Guide" button that opens a dialog for uploading CSV order guides from Sysco, US Foods, or GFS. Smart matching engine uses fuzzy string similarity (levenshtein distance) to match vendor products to existing inventory items, scoring confidence 0-100. Auto-match threshold is 85+ (high confidence), 60-84 requires review (medium confidence), <60 creates new items. Order guide review page displays three groups: auto-matched (green badges, immediate approval), needs review (yellow badges, manual linking or creation), and new items (blue badges, creates inventory + vendor items). Approval workflow creates vendor_items for matched products with current pricing from CSV, auto-creates inventory items for new products with smart defaults (category detection, unit mapping, dual pricing initialization). Backend tables: `order_guides` (tracks upload metadata, status, vendor), `order_guide_lines` (staged products with match status/confidence/linked IDs). API endpoints: POST `/api/order-guides/upload` (parse & match), GET `/api/order-guides/:id/review` (retrieve staging), POST `/api/order-guides/:id/approve` (finalize import). Vendor detection auto-identifies Sysco/GFS/US Foods from vendor name for format-specific CSV parsing.
- Default Categories: All companies automatically start with three default categories: "Frozen", "Walk-In", and "Dry/Pantry". Companies can customize and add additional categories as needed.
- Comprehensive Kitchen Units: System includes 40 comprehensive kitchen measurement units covering both imperial and metric systems. Companies have a `preferredUnitSystem` setting (imperial/metric/both) to control default unit display preferences.
- Unit Compatibility Filtering: Recipe builder implements intelligent unit filtering to prevent incompatible unit selections. When adding or editing ingredients, the unit dropdown automatically filters to show only units matching the ingredient's measurement kind (weight/volume/count) and the company's preferredUnitSystem setting (imperial/metric/both). Backend endpoint GET `/api/units/compatible?unitId=<uuid>` returns filtered units. Frontend uses React Query with custom queryFn to fetch compatible units, implementing length-aware fallback `(compatibleUnits?.length ? compatibleUnits : allUnits)` to ensure dropdown always has options.
- Recipe Cost Caching: Recipes list displays real-time calculated costs instead of stale database values. GET /api/recipes endpoint calculates costs on-demand using bulk-loaded data with parallel processing and per-request memoization. Calculated costs overwrite the `computedCost` field in API responses. A 5-minute cache (`recipes:costs:${companyId}`) optimizes performance. Cache invalidation via `cacheInvalidator.invalidateRecipes()` ensures the cache is cleared when recipes, recipe components, or inventory prices changes.
- Order Completion Timestamps: Orders page displays completion timestamps via mouseover tooltips on status badges. For transfer orders with `status="completed"`, tooltip shows `transferOrder.completedAt`. For purchase orders with `status="received"`, tooltip shows the latest completed receipt's `receivedAt` timestamp. Only orders with `status="completed"` or "received" AND a valid completedAt value show the tooltip.
- Date Formatting & Timezone Safety: System uses single-timezone architecture optimized for restaurants operating in one timezone. **Storage**: Date-only fields (count_date, sales_date, expected_date) are stored as PostgreSQL `timestamp without time zone` at midnight UTC using `Date.UTC(year, month-1, day)` to avoid timezone shifts. **API Boundaries**: Backend sends YYYY-MM-DD strings extracted using UTC methods (`getUTCFear()`, etc.), frontend sends YYYY-MM-DD strings via `<input type="date">`, schema transforms convert YYYY-MM-DD → `Date.UTC()` before database storage. **Display**: All date displays use `formatDateString()` helper that parses YYYY-MM-DD strings into local timezone Date objects. This architecture prevents dates from shifting by ±1 day during timezone conversions while maintaining compatibility with Drizzle ORM's type system.
- Receiving Page Status Display: Consolidated duplicate status badges into single Badge component with conditional styling. Shows green "received" badge when receipt is completed OR purchase order status is "received`.
- Transfer Order Usage Tracking: Usage calculation on Purchase Order detail page now accounts for outbound transfers to prevent over-ordering. Formula updated to: Usage = Previous Count + Received - Transferred - Current. New "Transfers" column displays between "Current" and "Usage" and "Usage" columns, showing quantities transferred out during the count period. Multi-tenant data isolation enforced with comprehensive validation.
- Conditional Transfer UI Rendering: Transfer-related features are automatically hidden for single-store companies (transfers require minimum 2 stores). Sidebar's "Transfer Orders" menu item is conditionally rendered based on accessible stores count. Purchase Order detail page's "Transfers" column is conditionally rendered using the same logic.
- Tare Weight Categories & Case Counting: Categories table includes `isTareWeightCategory` field (integer 0/1, default 0) to identify categories that enable case counting in inventory counts. Storage Locations table includes `allowCaseCounting` field (integer 0/1, default 0) to enable case count fields for items in specific locations. Both fields appear as checkboxes in their respective management UIs.
- Inventory Count Smooth Scrolling Anchors: Category and location filter cards implement smooth scrolling to corresponding accordion sections. `generateAnchorId()` helper creates URL-safe IDs. `scrollToSection()` waits 300ms for accordion expansion before scrolling, respects `prefers-reduced-motion` accessibility preference, and focuses trigger elements for keyboard navigation. Accordion uses controlled state that resets when groupBy mode changes.
- Inventory Count Layout Optimization: Accordion headers show simplified layout (group name + total value only, item count hidden on mobile). Location value rows within category view use CSS grid layout (160px label, flexible input, 100px right-aligned value column) for clean alignment. Previous count value moved to dedicated footer section. Alternating row striping (bg-muted/20 opacity) applied to location input rows.
- Inventory Count Text Search: Count session page includes text search input that filters items by name or PLU/SKU (case-insensitive). Search integrates seamlessly with existing grouping modes and other filters. "Clear Filters" button clears search along with other filters. Empty accordion groups are automatically hidden when search filters out all items.
- Inventory Count Back to Top Button: Count session page displays a floating "Back to Top" button when user scrolls down more than 300px. Button appears as a rounded circle with ArrowUp icon, positioned at bottom-6 right-6 with shadow-lg and z-50 stacking. Listens directly to main element scroll events (handles `overflow-auto` on main container) with fallback to window scroll. Clicking button smoothly scrolls both window and main element to top. Automatically hides when near top of page. Provides easy navigation on long count sessions without requiring manual sampling.
- TFC Theoretical Usage Detail: TFC Variance Report features clickable theoretical usage values that opens a detailed breakdown modal. Dialog displays summary cards (Total Quantity, Total Cost, Menu Items count) and a Menu Item Breakdown table showing which menu items contributed to theoretical usage. Backend endpoint `/api/tfc/variance/theoretical-detail` aggregates stored theoretical_usage_lines data across multiple runs within the count period, distributing usage proportionally based on menu item quantities sold. Data is fetched lazily via React Query only when dialog opens, with per-item caching for performance.
- TFC Purchase Order Display: Purchase orders delivered during the count period are displayed as "M/D/YY - Vendor Name" format with multiple orders separated by "|" characters. Backend fetches vendor data and includes vendor names in the purchase order response. Frontend formats dates as single-digit month and day with 2-digit year.
- TFC Unit System Clarification: The `theoretical_usage_lines.requiredQtyBaseUnit` field stores quantities in each inventory item's unit (e.g., pounds for cheese, fluid ounces for liquids), NOT in micro-units. The term "base unit" refers to the inventory item's base unit, not the system's canonical base (grams/mL). Both actual usage (from inventory counts) and theoretical usage (from stored theoretical usage runs) are already in the same inventory-item-level units, requiring no conversion in variance calculations. The `units.toBaseRatio` field converts to canonical base units (grams/mL) and should NOT be used for variance comparisons. Recipe component calculations use `convertToBaseUnit()` to ensure recipe ingredients are converted into the target inventory item's unit before storage. The variance endpoint queries stored `theoretical_usage_lines` (which already have unit conversions applied) rather than recalculating from recipe components to ensure consistency with the theoretical detail modal.
- TFC Variance Cost Calculation: Variance cost impact is calculated as (variance units × weighted average cost per unit). The `getItemUsageBetweenCounts` function returns `pricePerUnit` populated from `inventory_items.avgCostPerUnit` (weighted average average cost) for accurate cost calculations. Variance cost = (actualUsage - theoreticalUsage) × pricePerUnit.
- TFC Variance Table Enhancements: Variance report includes WAC (Weighted Average Cost) column positioned between Variance % and Cost Impact, displaying the per-unit cost used in variance calculations. Table includes totals row at bottom showing sum of all variance costs with color-coded display (red for over-usage, green for savings) and bold styling with muted background.
- TFC Purchase Order Receipt Modal: Purchase orders displayed in the "Purchase Orders Delivered" section are clickable, opening a modal dialog that shows receipt details without leaving the variance page. Modal displays received items with quantities, prices, and line totals, along with receipt status and timestamp. Includes "View Full Order" button to navigate to the complete purchase order page. Backend endpoint `/api/purchase-orders/:poId/receipts` nourishes receipt lines with inventory item names, vendor SKUs, and unit names for complete display.
- TFC Variance Summary Cards: Variance page displays inventory count periods as a grid of clickable summary cards insteads of a dropdown selector. Each card shows: Inventory Date, Inventory Value (total count value), Total Sales (POS sales for the period), Total Variance $ and % (aggregated across all items). Cards use responsive layout (1/2/3 columns on mobile/tablet/desktop) with hover elevation and selected state styling (border-primary bg-accent). Backend endpoint GET `/api/tfc/variance/summaries?storeId=X` calculates and returns summaries for all count periods. Frontend auto-selects the most recent period on load and clears selection when store changes to prevent stale count ID/store ID mismatches. Provides immediate visual overview of variance trends across multiple periods.
- Dashboard Stat Cards: Dashboard displays four clickable stat cards providing quick navigation to key pages. Cards show: Active Items (links to /inventory), Recent Variance (links to /variance with color-coded red/green for losses/savings), Inventory Counts (links to /inventory-sessions), and Menu Items (links to /menu-items showing total active menu items at the selected store). Recent Variance card replaced the previous "Inventory Value" stat and displays most recent week's variance with date. Menu Items card replaced "Recent Orders" stat since detailed order information is already shown in the Recent Orders table below the stat cards.
- Dashboard Actual Received Values: Recent Orders section on Dashboard displays actual received values from completed receipts instead of expected order totals for received purchase orders. Backend `/api/receipts` enriched to calculate and include `totalAmount` field (sum of receivedQty × priceEach from receipt lines) for each receipt. Frontend creates receipt lookup map by purchase order ID and displays actual total when completed receipts exist, falling back to expected totalAmount for non-received orders.
- Dashboard Pending Order Deadlines & Critical Inventory Split-Screen: Dashboard displays split-screen layout (50/50 on desktop, stacked on mobile) showing pending purchase orders and critical inventory items side-by-side. Left section shows pending purchase orders with upcoming deadlines based on vendor delivery schedules. Backend endpoint `/api/purchase-orders/deadlines` calculates next delivery dates using vendor `deliveryDays` (searches from today, including same-day deliveries), computes order deadlines as (delivery date - `leadDaysAhead`), and returns urgency flags (isUrgent for deadlines ≤1 day, isPastDue for negative days). Displays up to 10 deadlines with color-coded visual indicators: red for past due, orange for urgent (today/tomorrow), default for normal). Each deadline shows vendor name, internal order ID, deadline date, delivery date, and days until deadline badge. Right section shows critical inventory items where estimated on-hand is below reorder level. Items are sorted by deficit (reorder level - estimated on-hand) with most critical first. Shows up to 20 items with color-coded badges: red for critical (<50% of reorder level) and orange for low (≥50%). Each item displays on-hand quantity, reorder level, and deficit percentage. Both sections use ScrollArea with fixed 400px height for equal sizing and smooth scrolling. All items are clickable links (orders → /orders/:id, inventory → /inventory/:id). "View all" buttons appear when item counts exceeds display limits (>10 for orders, 20 for inventory). Split-screen conditionally renders only when at least one section has data to display.
- Dashboard Recent Orders Mixed Display: Dashboard "Recent Orders" section displays both purchase and transfer orders combined, sorted by creation date (most recent first), showing the last 3 orders. Transfer orders are fetched via `/api/transfer-orders` and filtered by selected store (matching either fromStoreId or toStoreId). Combined orders include a type field ('purchase' | 'transfer') for conditional rendering. Transfer orders display "FromStore → ToStore" format instead of vendor names, are labeled as "Transfer #{id}", and link to `/transfer-orders/{id}`. Purchase orders display vendor names, are labeled as "Purchase #{id}", show dollar amounts (actual received or expected total), and link to `/purchase-orders/{id}` (pending) or `/receiving/{id}`). All orders display color-coded status badges consistent with Orders page styling.
- Dashboard Inventory Value Display: Dashboard "Recent Inventory" section displays a single clickable line showing the most recent inventory count with large value display (text-2xl), date, and item count. When 2+ historical counts exist, displays average inventory value calculated across all counts at the selected store with color-coded comparison badge (green for below average, red for above). Backend endpoint GET `/api/inventory-count-lines?storeId={id}` returns aggregated count lines for average calculation with multi-tenant security validation (global admins can access any store, company users restricted to their own stores). Frontend query uses React Query with conditional enable guard to prevent premature API calls before store selection.
- Transfer Orders Clickable Links: Transfer Orders list page displays Transfer IDs as visually obvious clickable links styled with primary color (`text-primary hover:underline cursor-pointer font-medium`) instead of ghost buttons. Clicking a Transfer ID navigates to `/transfer-orders/{id}` detail page for viewing/editing the transfer order.
- Transfer Order Item Filtering: Transfer order detail page implements status-based item filtering to provide clean, focused views. When status is "pending" (edit mode), all inventory items are displayed so users can add/remove items from the transfer. When status is "in_transit" or "completed" (receive/view mode), only items with quantity > 0 are displayed, eliminating clutter from empty rows. Total value calculation reflects only displayed items. This ensures receiving pages show only the items actually being transferred.
- Order Status Color-Coded Badges: Both Orders page and Dashboard Recent Orders section display vibrant color-coded status badges: yellow/pending, blue/ordered, purple/in_transit, green/received and completed. Status badges use consistent styling across all pages with background/text/border coordination for clear visual status identification.
- QuickBooks Online Integration: Fully functional OAuth 2.0 integration completed. Multi-tenant architecture supports both company-level and store-level QB connections with store-level connections overriding company-level. Backend includes four tables: `quickbooks_connections` (OAuth tokens with company/store isolation), `quickbooks_vendor_mappings` (maps FnBcostpro vendors to QB vendors), `quickbooks_sync_logs` (tracks sync status with retry logic), `quickbooks_token_logs` (structured logging for token refresh events with success/failure tracking). OAuth flow uses HMAC-SHA256 signed state parameters to prevent tampering and replay attacks and automatic redirect URI construction. All routes include multi-tenant security validation. Storage interface provides complete CRUD operations for connections, mappings, sync logs, and token logs. Settings → Integrations tab displays connection status, expiry dates, connection level (company-wide vs store-specific), and disconnect functionality. Production-ready token auto-refresh infrastructure includes: `refreshTokenIfNeeded()` with 5-minute buffer, structured logging, `refreshAllActiveConnections()` utility, hourly scheduled background job, feature-flag guard, and admin-triggered manual refresh endpoint.
- QuickBooks Selective Vendor Import: Opt-in vendor synchronization workflow allows users to preview and select which QB vendors to import. "Sync Vendors from QuickBooks" button opens preview dialog showing all QB vendors with intelligent match detection (already synced, exact match, possible match, new vendor). Color-coded status badges indicate sync state. Users select vendors via checkboxes with "Select All" functionality for new vendors and exact matches. Already-synced vendors and possible matches are read-only to prevent conflicts. Backend endpoints: GET `/api/quickbooks/vendors/preview` returns preview with match detection, POST `/api/quickbooks/vendors/sync` accepts selectedVendorIds array for selective import. Vendors schema includes QB sync fields: qbVendorId (QB vendor ID), sourceOfTruth (manual/quickbooks), lastSyncAt (last sync timestamp), syncStatus (success/failed/pending). Import process creates new vendors for unmatched QB vendors, links exact matches via vendor mappings, and updates QB-managed vendors with latest data. QuickBooks is source of truth for core fields (name, tax ID, payment terms), FnBcostpro retains restaurant-specific fields (deliveryDays, leadDaysAhead, certifications), but FnBcostpro is the source of truth for all of these fields.
- Estimated On-Hand Inventory: Inventory Items page displays an "Est. On-Hand" column showing real-time estimated current inventory based on last physical count plus activity since then. Calculation formula: Estimated On-Hand = Last Count + Purchases Since Count - Waste Since Count - Theoretical Usage Since Count - Transfers Out. Backend storage function `getEstimatedOnHand(companyId, storeId)` aggregates all inventory movements since the last count with strict multi-tenant data isolation (all queries filter by both companyId and storeId). Backend endpoint GET `/api/inventory-items/estimated-on-hand?storeId={id}` validates store ownership before returning data and is positioned BEFORE the `:id` parameterized route to prevent route collision. Frontend displays estimated values in blue text (text-blue-600 dark:text-blue-400) in dedicated column positioned after "Quantity". Shows "—" placeholder when no inventory count exists for the selected store. Query only enabled when a specific store is selected (not "all"). Real-time updates: Estimated on-hand cache is automatically invalidated when waste is logged, receipts are completed, inventory counts are applied, transfers are executed/received, or sales CSV files are uploaded (triggering theoretical usage calculations), ensuring values stay current. Note: Sales on the SAME DAY as an inventory count are excluded from estimated on-hand calculations (they were part of what was counted) - only sales from days AFTER the count date reduce inventory estimates.
- Estimated On-Hand Breakdown Modal: Inventory Items page features clickable estimated on-hand values that open a detailed breakdown dialog showing inventory activity since the last count. Backend endpoint GET `/api/inventory-items/:itemId/estimated-on-hand-breakdown?storeId={storeId}` returns structured breakdown data with three summary cards (Last Count, Net Change, Estimated On-Hand) and detailed activity sections (Receipts, Waste, Theoretical Usage, Transfers). Returns 404 when no inventory count exists, which frontend handles gracefully by displaying empty state with guidance to complete a count. Implementation includes: leftJoin for purchase orders/vendors (handles receipts without POs showing as "Direct Receipt"), transfer filtering to exclude null completedAt dates (preserves data integrity), formatReasonCode() helper mapping waste codes to human-readable text (e.g., "SPOILED" → "Spoiled"), and frontend 404 handling returning null for React Query to show Package icon with "No breakdown available" message. All queries use strict multi-tenant validation and UTC date handling for timezone safety.
- Sales CSV Date Parsing: CSV upload date parsing fixed to prevent timezone-induced date shift bug. Sales dates in YYYY-MM-DD format are parsed using `Date.UTC()` to create dates at midnight UTC, ensuring CSV dates like "2025-11-21" are stored as 2025-11-21 00:00:00 UTC in PostgreSQL (timestamp without time zone). This prevents the previous bug where dates created in local timezone would shift backwards by one day when converted to UTC during database storage.
- Sales CSV Upload Cache Invalidation: Frontend cache for estimated on-hand inventory is now automatically invalidated after CSV sales uploads complete. This ensures theoretical usage calculations immediately reduce estimated on-hand values without requiring manual page refresh.

# System Architecture

- **Frontend**: Mobile-first React 18 SPA with TypeScript, Vite, `shadcn/ui` (Radix UI, Tailwind CSS), TanStack Query, React Context, and Wouter for routing.
- **Backend**: Node.js (TypeScript) with Express.js and Zod for data validation.
- **Database**: PostgreSQL with Drizzle ORM, hosted on Neon serverless, utilizing connection pooling, composite indexes, and atomic transactions.
- **Application Structure**: Multi-tenant Single Page Application (SPA) with strict data isolation.
- **UI/UX Decisions**: Mobile-first design, intuitive recipe creation, dynamic dashboards, filterable data tables, consistent color-coded status badges, conditional UI rendering, smooth scrolling, and optimized inventory count layouts.
- **Technical Implementations**: Comprehensive unit conversion, multi-level nested recipe costing, dual inventory pricing (Last Cost & Weighted Average Cost), robust multi-tenant QuickBooks Online integration, intelligent vendor order guide import, real-time recipe cost calculation with caching, dynamic estimated on-hand inventory with automated cache invalidation, detailed Theoretical Food Cost (TFC) variance reporting, and single-timezone date handling.
- **System Design Choices**: Adheres to strict multi-tenancy principles, micro-unit precision for all inventory calculations, HMAC-SHA256 for secure OAuth, extensive server-side validation, and robust vendor relationship management.

# External Dependencies

- **Database Services**: Neon serverless PostgreSQL.
- **Real-time Communication**: `ws` library (WebSockets).
- **Image Processing**: Sharp library.
- **Object Storage**: Replit's native object storage solution.
- **Vendor Integrations**: Custom adapters for Sysco, GFS, and US Foods order guides.
- **QuickBooks Online Integration**: `intuit-oauth` package for OAuth 2.0.