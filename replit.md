# Overview

This project is a multi-company inventory management and recipe costing system for food service businesses. Its primary goal is to enhance operational efficiency, minimize waste, and improve profitability across various business locations. Key capabilities include precise unit conversions, management of nested recipes, integration with POS sales data, detailed variance reporting, dual inventory pricing, streamlined purchasing processes, and robust business intelligence tools. The ambition is to establish this system as a leading financial management solution in the food service industry.

# User Preferences

- Preferred communication style: Simple, everyday language.
- Default Unit of Measure for Inventory Items: Pound should be the default unit when creating new inventory items.
- Unit Abbreviation: "Pound" displays as "lb." throughout the UI.
- Yield Field: Yield is stored as a percentage value (0-100).
- Par Level & Reorder Level: Stored on `inventory_items` table as default values, overrideable at the store level.
- Active/Inactive Status: Dual-level active status (global and store-specific).
- Store Locations: Inventory items require assignment to at least one store location during creation.
- Storage Locations: Inventory items can be associated with multiple storage locations; at least one is required. Storage Locations page features drag-and-drop reordering. Inventory count displays respect storage location sortOrder.
- Recipe `canBeIngredient`: Recipes include a `canBeIngredient` checkbox field (0/1 in DB) to mark if they can be used as ingredients in other recipes.
- Category Filtering in Recipe Builder: Categories include a `showAsIngredient` field (0/1 in DB) controlling whether items in this category appear in the recipe builder's ingredient selection.
- Recipe Cost Calculation Fix: Ingredient prices must be converted to base unit prices before multiplication.
- Recipe Company Isolation: Implement comprehensive company-level isolation for recipes and recipe components.
- Recipe Cost Recalculation on Inventory Price Changes: Automatically recalculate all affected recipes when an inventory item's price changes, including nested recipes, ensuring recalculation in dependency order.
- Number Input Fields: All number input fields throughout the application have spinner controls (up/down arrows) removed.
- Recipe Name Capitalization: Recipe names are automatically displayed with the first letter capitalized in all UI presentations while preserving the original database values.
- Placeholder Recipe System: During CSV menu import onboarding, placeholder recipes are automatically created for all recipe items (isRecipeItem=1), containing 1 oz of a "Placeholder Ingredient" and flagged with `isPlaceholder=1`. Menu Items page displays recipe status badges (Placeholder/Complete/Needs Recipe/N/A). Recipe saves set `isPlaceholder` to 0, converting placeholders to complete recipes. Recipe saves trigger Menu Items page refresh to ensure badge status and recipe costs update immediately.
- Menu Item Management: Menu items can be created manually via "Add Menu Item" dialog with form validation (required: name, PLU/SKU; optional: department, category, size, price, recipe, isRecipeItem flag). Recipe selection dropdown allows linking recipes during creation or editing. "Create new recipe with this name" link navigates to Recipe Builder with menu item name pre-populated. Menu items can be edited by clicking the item name or via the actions dropdown menu. Edit dialog includes all fields plus price and recipe selection. Active/inactive status toggle via dropdown actions menu. Department, category, and type filters (Recipe Item/Non-Recipe Item/All) enable easy sorting and filtering. Table displays Recipe Cost (computed from recipe) and Price columns, with Status and Type columns removed for cleaner UI. SKU cleanup script automatically removes pipe symbols from imported POS data and generates abbreviated SKUs (max 10 characters) from item names, with sequential numbering for duplicates.
- Menu Item Store Assignment: Menu items require assignment to at least one store during creation and editing, matching inventory items pattern. Store checkboxes appear in both Add and Edit dialogs with validation.
- Recipe Cost Display: Menu Items page displays computed recipe costs for all menu items that have recipes assigned, including both placeholder and complete recipes. Items without recipes show "-" in the Recipe Cost column.
- Dual Pricing Model: Inventory items track both Last Cost (pricePerUnit - most recent purchase price) and Weighted Average Cost (avgCostPerUnit - WAC calculated across all receipts). Inventory Items page displays both price columns. WAC is calculated during receiving using company-wide quantities: `((totalCompanyQty * currentAvgCost) + (receivedQty * received * receivedPrice)) / (totalCompanyQty + qty))`.
- Vendor Price Comparison: Purchase order creation includes a "Compare Prices" button (TrendingDown icon) on each item row that opens a dialog showing all vendor prices for an item. The dialog displays vendor name, SKU, case size, unit price, and case price, sorted by case price (lowest first). The lowest-priced vendor is highlighted with a "Best Price" badge. Uses vendor-specific case sizes and includes zero-priced items (promotional offers). Only excludes vendors with null/undefined prices.
- Vendor-Specific Purchase Order Pricing: Purchase orders use vendor-specific pricing (vendor_items.lastPrice) instead of general inventory pricing (inventory_items.pricePerUnit). All pricing logic uses nullish coalescing (`??`) to preserve legitimate zero-priced vendor items while falling back to inventory pricing only when vendor prices are null/undefined.
- Vendor Delivery Scheduling: Delivery scheduling is managed at the vendor level. Each vendor has `deliveryDays` (array of weekdays when vendor delivers) and `leadDaysAhead` (number of days before delivery that orders must be placed). Vendors page includes checkboxes for each weekday and a numeric input for lead days ahead in the add/edit vendor dialog. Lead time field has been completely removed from vendor items.
- Vendor Deletion Constraints: Vendors with purchase orders or vendor items (products) cannot be deleted - only deactivated. Backend enforces constraints returning 400 errors with guidance to deactivate instead. Frontend displays error messages via toast notifications.
- Misc Grocery Vendor Protection: "Misc Grocery" is a system vendor automatically created for each company. Frontend hides delete button for vendors with names containing "misc grocery" (case-insensitive). Backend additionally blocks deletion attempts via API.
- Vendor Compliance Fields: Vendors table includes compliance and accounting fields to support expense gateway functionality when products are received. Fields include: `active` (integer 0/1, default 1) for vendor status, `taxId` (text) for Tax ID/EIN, `requires1099` (integer 0/1, default 0) for 1099 reporting requirements, `paymentTerms` (text) for payment terms (e.g., "Net 30", "COD"), `creditLimit` (real) for maximum credit limit, and `certifications` (text array) for vendor certifications (e.g., Organic, Kosher, Halal). Vendors page add/edit dialog includes "Compliance & Accounting" section with all fields. QuickBooks vendor mapping automatically filters to show only active vendors (active = 1).
- Vendor Order Guide CSV Import: Vendors page includes "Import Order Guide" button that opens a dialog for uploading CSV order guides from Sysco, US Foods, or GFS. Smart matching engine uses fuzzy string similarity (levenshtein distance) to match vendor products to existing inventory items, scoring confidence 0-100. Auto-match threshold is 85+ (high confidence), 60-84 requires review (medium confidence), <60 creates new items. Order guide review page displays three groups: auto-matched (green badges, immediate approval), needs review (yellow badges, manual linking or creation), and new items (blue badges, creates inventory + vendor items). Approval workflow creates vendor_items for matched products with current pricing from CSV, auto-creates inventory items for new products with smart defaults (category detection, unit mapping, dual pricing initialization). Backend tables: `order_guides` (tracks upload metadata, status, vendor), `order_guide_lines` (staged products with match status/confidence/linked IDs). API endpoints: POST `/api/order-guides/upload` (parse & match), GET `/api/order-guides/:id/review` (retrieve staging), POST `/api/order-guides/:id/approve` (finalize import). Vendor detection auto-identifies Sysco/GFS/US Foods from vendor name for format-specific CSV parsing.
- Default Categories: All companies automatically start with three default categories: "Frozen", "Walk-In", and "Dry/Pantry". Companies can customize and add additional categories as needed.
- Comprehensive Kitchen Units: System includes 40 comprehensive kitchen measurement units covering both imperial and metric systems. Companies have a `preferredUnitSystem` setting (imperial/metric/both) to control default unit display preferences.
- Unit Compatibility Filtering: Recipe builder implements intelligent unit filtering to prevent incompatible unit selections. When adding or editing ingredients, the unit dropdown automatically filters to show only units matching the ingredient's measurement kind (weight/volume/count) and the company's preferredUnitSystem setting (imperial/metric/both). Backend endpoint GET `/api/units/compatible?unitId=<uuid>` returns filtered units. Frontend uses React Query with custom queryFn to fetch compatible units, implementing length-aware fallback `(compatibleUnits?.length ? compatibleUnits : allUnits)` to ensure dropdown always has options.
- Recipe Cost Caching: Recipes list displays real-time calculated costs instead of stale database values. GET /api/recipes endpoint calculates costs on-demand using bulk-loaded data with parallel processing and per-request memoization. Calculated costs overwrite the `computedCost` field in API responses. A 5-minute cache (`recipes:costs:${companyId}`) optimizes performance. Cache invalidation via `cacheInvalidator.invalidateRecipes()` ensures the cache is cleared when recipes, recipe components, or inventory prices changes.
- Order Completion Timestamps: Orders page displays completion timestamps via mouseover tooltips on status badges. For transfer orders with `status="completed"`, tooltip shows `transferOrder.completedAt`. For purchase orders with `status="received"`, tooltip shows the latest completed receipt's `receivedAt` timestamp. Only orders with `status="completed"` or "received" AND a valid completedAt value show the tooltip.
- Date Formatting & Timezone Safety: All date displays use `formatDateString()` helper that parses YYYY-MM-DD strings into local timezone Date objects. Purchase order Expected Date field uses standard HTML `<input type="date">`. Date flow is entirely string-based: backend sends YYYY-MM-DD, frontend stores/edits as string, display converts to local timezone only.
- Receiving Page Status Display: Consolidated duplicate status badges into single Badge component with conditional styling. Shows green "received" badge when receipt is completed OR purchase order status is "received`.
- Transfer Order Usage Tracking: Usage calculation on Purchase Order detail page now accounts for outbound transfers to prevent over-ordering. Formula updated to: Usage = Previous Count + Received - Transferred - Current. New "Transfers" column displays between "Current" and "Usage" and "Usage" columns, showing quantities transferred out during the count period. Multi-tenant data isolation enforced with comprehensive validation.
- Conditional Transfer UI Rendering: Transfer-related features are automatically hidden for single-store companies (transfers require minimum 2 stores). Sidebar's "Transfer Orders" menu item is conditionally rendered based on accessible stores count. Purchase Order detail page's "Transfers" column is conditionally rendered using the same logic.
- Tare Weight Categories & Case Counting: Categories table includes `isTareWeightCategory` field (integer 0/1, default 0) to identify categories that enable case counting in inventory counts. Storage Locations table includes `allowCaseCounting` field (integer 0/1, default 0) to enable case count fields for items in specific locations. Both fields appear as checkboxes in their respective management UIs.
- Inventory Count Smooth Scrolling Anchors: Category and location filter cards implement smooth scrolling to corresponding accordion sections. `generateAnchorId()` helper creates URL-safe IDs. `scrollToSection()` waits 300ms for accordion expansion before scrolling, respects `prefers-reduced-motion` accessibility preference, and focuses trigger elements for keyboard navigation. Accordion uses controlled state that resets when groupBy mode changes.
- Inventory Count Layout Optimization: Accordion headers show simplified layout (group name + total value only, item count hidden on mobile). Location value rows within category view use CSS grid layout (160px label, flexible input, 100px right-aligned value column) for clean alignment. Previous count value moved to dedicated footer section. Alternating row striping (bg-muted/20 opacity) applied to location input rows.
- Inventory Count Text Search: Count session page includes text search input that filters items by name or PLU/SKU (case-insensitive). Search integrates seamlessly with existing grouping modes and other filters. "Clear Filters" button clears search along with other active filters. Empty accordion groups are automatically hidden when search filters out all items.
- TFC Theoretical Usage Detail: TFC Variance Report features clickable theoretical usage values that opens a detailed breakdown modal. Dialog displays summary cards (Total Quantity, Total Cost, Menu Items count) and a Menu Item Breakdown table showing which menu items contributed to theoretical usage. Backend endpoint `/api/tfc/variance/theoretical-detail` aggregates stored theoretical_usage_lines data across multiple runs within the count period, distributing usage proportionally based on menu item quantities sold. Data is fetched lazily via React Query only when dialog opens, with per-item caching for performance.
- TFC Purchase Order Display: Purchase orders delivered during the count period are displayed as "M/D/YY - Vendor Name" format with multiple orders separated by "|" characters. Backend fetches vendor data and includes vendor names in the purchase order response. Frontend formats dates as single-digit month and day with 2-digit year.
- TFC Unit System Clarification: The `theoretical_usage_lines.requiredQtyBaseUnit` field stores quantities in each inventory item's unit (e.g., pounds for cheese, fluid ounces for liquids), NOT in micro-units. The term "base unit" refers to the inventory item's base unit, not the system's canonical base (grams/mL). Both actual usage (from inventory counts) and theoretical usage (from stored theoretical usage runs) are already in the same inventory-item-level units, requiring no conversion in variance calculations. The `units.toBaseRatio` field converts to canonical base units (grams/mL) and should NOT be used for variance comparisons. Recipe component calculations use `convertToBaseUnit()` to ensure recipe ingredients are converted into the target inventory item's unit before storage. The variance endpoint queries stored `theoretical_usage_lines` (which already have unit conversions applied) rather than recalculating from recipe components to ensure consistency with the theoretical detail modal.
- TFC Variance Cost Calculation: Variance cost impact is calculated as (variance units × weighted average cost per unit). The `getItemUsageBetweenCounts` function returns `pricePerUnit` populated from `inventory_items.avgCostPerUnit` (weighted average average cost) for accurate cost calculations. Variance cost = (actualUsage - theoreticalUsage) × pricePerUnit.
- TFC Variance Table Enhancements: Variance report includes WAC (Weighted Average Cost) column positioned between Variance % and Cost Impact, displaying the per-unit cost used in variance calculations. Table includes totals row at bottom showing sum of all variance costs with color-coded display (red for over-usage, green for savings) and bold styling with muted background.
- TFC Purchase Order Receipt Modal: Purchase orders displayed in the "Purchase Orders Delivered" section are clickable, opening a modal dialog that shows receipt details without leaving the variance page. Modal displays received items with quantities, prices, and line totals, along with receipt status and timestamp. Includes "View Full Order" button to navigate to the complete purchase order page. Backend endpoint `/api/purchase-orders/:poId/receipts` nourishes receipt lines with inventory item names, vendor SKUs, and unit names for complete display.
- TFC Variance Summary Cards: Variance page displays inventory count periods as a grid of clickable summary cards insteads of a dropdown selector. Each card shows: Inventory Date, Inventory Value (total count value), Total Sales (POS sales for the period), Total Variance $ and % (aggregated across all items). Cards use responsive layout (1/2/3 columns on mobile/tablet/desktop) with hover elevation and selected state styling (border-primary bg-accent). Backend endpoint `/api/tfc/variance/summaries?storeId=X` calculates and returns summaries for all count periods. Frontend auto-selects the most recent period on load and clears selection when store changes to prevent stale count ID/store ID mismatches. Provides immediate visual overview of variance trends across multiple periods.
- QuickBooks Online Integration: Fully functional OAuth 2.0 integration completed. Multi-tenant architecture supports both company-level and store-level QB connections with store-level connections overriding company-level. Backend includes four tables: `quickbooks_connections` (OAuth tokens with company/store isolation), `quickbooks_vendor_mappings` (maps FoodCost Pro vendors to QB vendors), `quickbooks_sync_logs` (tracks sync status with retry logic), `quickbooks_token_logs` (structured logging for token refresh events with success/failure tracking). OAuth flow uses HMAC-SHA256 signed state parameters to prevent tampering and replay attacks and replay attacks and automatic redirect URI construction. All routes include multi-tenant security validation. Storage interface provides complete CRUD operations for connections, mappings, sync logs, and token logs. Settings → Integrations tab displays connection status, expiry dates, connection level (company-wide vs store-specific), and disconnect functionality. Production-ready token auto-refresh infrastructure includes: `refreshTokenIfNeeded()` with 5-minute buffer, structured logging, `refreshAllActiveConnections()` utility, hourly scheduled background job, feature-flag guard, and admin-triggered manual refresh endpoint.
- QuickBooks Selective Vendor Import: Opt-in vendor synchronization workflow allows users to preview and select which QB vendors to import. "Sync Vendors from QuickBooks" button opens preview dialog showing all QB vendors with intelligent match detection (already synced, exact match, possible match, new vendor). Color-coded status badges indicate sync state. Users select vendors via checkboxes with "Select All" functionality for new vendors and exact matches. Already-synced vendors and possible matches are read-only to prevent conflicts. Backend endpoints: GET `/api/quickbooks/vendors/preview` returns preview with match detection, POST `/api/quickbooks/vendors/sync` accepts selectedVendorIds array for selective import. Vendors schema includes QB sync fields: qbVendorId (QB vendor ID), sourceOfTruth (manual/quickbooks), lastSyncAt (last sync timestamp), syncStatus (success/failed/pending). Import process creates new vendors for unmatched QB vendors, links exact matches via vendor mappings, and updates QB-managed vendors with latest data. QuickBooks is source of truth for core fields (name, tax ID, payment terms), FoodCost Pro retains restaurant-specific fields (deliveryDays, leadDaysAhead, certifications).

# System Architecture

- **Frontend**: React 18 (TypeScript, Vite) with `shadcn/ui` (Radix UI, Tailwind CSS), TanStack Query, React Context, and Wouter, designed for a compact, mobile-first, and touch-friendly user experience.
- **Backend**: Node.js (TypeScript) with Express.js and Zod for robust validation.
- **Database**: PostgreSQL managed via Drizzle ORM, leveraging connection pooling, composite indexes, and atomic transactions.
- **Application Structure**: Multi-tenant Single Page Application (SPA) with strict data isolation, a micro-unit system, a pluggable adapter pattern for external integrations, centralized order management, HMAC-SHA256 for secure OAuth, Redis caching, and response compression.
- **UI/UX Decisions**: Compact navigation, intuitive Recipe Builder with real-time cost updates, sortable/filterable data tables, theme toggling, conditional UI rendering, optimized inventory count layouts (smooth scrolling, text search, simplified accordion headers, CSS grid layouts), and advanced visual variance reporting (summary cards, detailed modals).
- **Technical Implementations**: Comprehensive unit conversion, multi-level nested recipe costing, a dual inventory pricing model (Last Cost & Weighted Average Cost), and a sophisticated QuickBooks Online integration with multi-tenant support, selective vendor import, and automated token refreshing.
- **Feature Specifications**: Includes dual inventory pricing, vendor price comparison, configurable vendor delivery schedules, automatic default categories, intelligent unit compatibility filtering, 5-minute recipe cost cache with invalidation, order completion timestamps, YYYY-MM-DD date formatting, consolidated receiving status badges, transfer order usage tracking, tare weight and case counting, theoretical usage detail modal, formatted TFC purchase order display, TFC unit system clarifications, TFC variance cost calculation using WAC, enhanced TFC variance table with WAC column and color-coded totals, TFC purchase order receipt modal, TFC variance summary cards, and multi-tenant QuickBooks Online Integration with selective vendor import and token auto-refresh.
- **System Design Choices**: Emphasizes multi-tenancy, strict data isolation, a micro-unit system for precision, and a pluggable adapter pattern for flexible integrations. Security is prioritized through HMAC-SHA256 for OAuth and comprehensive validation.

# External Dependencies

- **Database Services**: Neon serverless PostgreSQL.
- **Real-time Communication**: `ws` library (WebSockets).
- **Image Processing**: Sharp.
- **Object Storage**: Replit's native object storage.
- **Vendor Integrations**: Custom adapters for Sysco, GFS, and US Foods.
- **QuickBooks Online Integration**: `intuit-oauth` package.