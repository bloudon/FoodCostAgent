# Overview

This project is a multi-company inventory management and recipe costing system for food service businesses. Its primary goal is to boost operational efficiency, reduce waste, and maximize profitability across multiple locations. Key features include precise unit conversions, multi-level nested recipe management, POS sales data integration, detailed variance reporting, dual inventory pricing (Last Cost and Weighted Average Cost), streamlined purchasing, and robust business intelligence. It is designed as a scalable, multi-tenant solution to facilitate data-driven decision-making and profit optimization for multi-location food service operations.

# User Preferences

- Preferred communication style: Simple, everyday language.
- Default Unit of Measure for Inventory Items: Pound should be the default unit when creating new inventory items.
- Unit Abbreviation: "Pound" displays as "lb." throughout the UI.
- Yield Field: Yield is stored as a percentage value (0-100).
- Par Level & Reorder Level: Stored on `inventory_items` table as default values, overrideable at the store level.
- Active/Inactive Status: Dual-level active status (global and store-specific).
- Store Locations: Inventory items require assignment to at least one store location during creation.
- Storage Locations: Inventory items can be associated with multiple storage locations; at least one is required. Storage Locations page features drag-and-drop reordering. Inventory count displays respect storage location sortOrder.
- Recipe `canBeIngredient`: Recipes include a `canBeIngredient` checkbox field (0/1 in DB) to mark if they can be used as ingredients in other recipes.
- Category Filtering in Recipe Builder: Categories include a `showAsIngredient` field (0/1 in DB) controlling whether items in this category appear in the recipe builder's ingredient selection.
- Waste Percentage Removal: The waste percentage field has been removed from recipes.
- Recipe Cost Calculation Fix: Ingredient prices must be converted to base unit prices before multiplication.
- Recipe Company Isolation: Implement comprehensive company-level isolation for recipes and recipe components.
- Recipe Cost Recalculation on Inventory Price Changes: Automatically recalculate all affected recipes when an inventory item's price changes, including nested recipes, ensuring recalculation in dependency order.
- Number Input Fields: All number input fields throughout the application have spinner controls (up/down arrows) removed.
- Recipe Name Capitalization: Recipe names are automatically displayed with the first letter capitalized in all UI presentations while preserving the original database values.
- Placeholder Recipe System: During CSV menu import onboarding, placeholder recipes are automatically created for all recipe items (isRecipeItem=1), containing 1 oz of a "Placeholder Ingredient" and flagged with `isPlaceholder=1`. Menu Items page displays recipe status badges (Placeholder/Complete/Needs Recipe/N/A). Recipe saves set `isPlaceholder` to 0, converting placeholders to complete recipes. Recipe saves trigger Menu Items page refresh to ensure badge status and recipe costs update immediately.
- Menu Item Management: Menu items can be created manually via "Add Menu Item" dialog with form validation (required: name, PLU/SKU; optional: department, category, size, price, recipe, isRecipeItem flag). Recipe selection dropdown allows linking recipes during creation or editing. "Create new recipe with this name" link navigates to Recipe Builder with menu item name pre-populated. Menu items can be edited by clicking the item name or via the actions dropdown menu. Edit dialog includes all fields plus price and recipe selection. Active/inactive status toggle via dropdown actions menu. Department, category, and type filters (Recipe Item/Non-Recipe Item/All) enable easy sorting and filtering. Table displays Recipe Cost (computed from recipe) and Price columns, with Status and Type columns removed for cleaner UI. SKU cleanup script automatically removes pipe symbols from imported POS data and generates abbreviated SKUs (max 10 characters) from item names, with sequential numbering for duplicates.
- Menu Item Store Assignment: Menu items require assignment to at least one store during creation and editing, matching inventory items pattern. Store checkboxes appear in both Add and Edit dialogs with validation.
- Recipe Cost Display: Menu Items page displays computed recipe costs for all menu items that have recipes assigned, including both placeholder and complete recipes. Items without recipes show "-" in the Recipe Cost column.
- Dual Pricing Model: Inventory items track both Last Cost (pricePerUnit - most recent purchase price) and Weighted Average Cost (avgCostPerUnit - WAC calculated across all receipts). Inventory Items page displays both price columns. WAC is calculated during receiving using company-wide quantities: `((totalCompanyQty * currentAvgCost) + (receivedQty * received * receivedPrice)) / (totalCompanyQty + qty))`.
- Vendor Price Comparison: Purchase order creation includes a "Compare Prices" button (TrendingDown icon) on each item row that opens a dialog showing all vendor prices for an item. The dialog displays vendor name, SKU, case size, unit price, and case price, sorted by case price (lowest first). The lowest-priced vendor is highlighted with a "Best Price" badge. Uses vendor-specific case sizes and includes zero-priced items (promotional offers). Only excludes vendors with null/undefined prices.
- Vendor-Specific Purchase Order Pricing: Purchase orders use vendor-specific pricing (vendor_items.lastPrice) instead of general inventory pricing (inventory_items.pricePerUnit). All pricing logic uses nullish coalescing (`??`) to preserve legitimate zero-priced vendor items while falling back to inventory pricing only when vendor prices are null/undefined.
- Vendor Delivery Scheduling: Delivery scheduling is managed at the vendor level. Each vendor has `deliveryDays` (array of weekdays when vendor delivers) and `leadDaysAhead` (number of days before delivery that orders must be placed). Vendors page includes checkboxes for each weekday and a numeric input for lead days ahead in the add/edit vendor dialog. Lead time field has been completely removed from vendor items.
- Vendor Deletion Constraints: Vendors with purchase orders or vendor items (products) cannot be deleted - only deactivated. Backend enforces constraints returning 400 errors with guidance to deactivate instead. Frontend displays error messages via toast notifications.
- Misc Grocery Vendor Protection: "Misc Grocery" is a system vendor automatically created for each company. Frontend hides delete button for vendors with names containing "misc grocery" (case-insensitive). Backend additionally blocks deletion attempts via API.
- Default Categories: All companies automatically start with three default categories: "Frozen", "Walk-In", and "Dry/Pantry". Companies can customize and add additional categories as needed.
- Comprehensive Kitchen Units: System includes 40 comprehensive kitchen measurement units covering both imperial and metric systems. Companies have a `preferredUnitSystem` setting (imperial/metric/both) to control default unit display preferences.
- Unit Compatibility Filtering: Recipe builder implements intelligent unit filtering to prevent incompatible unit selections. When adding or editing ingredients, the unit dropdown automatically filters to show only units matching the ingredient's measurement kind (weight/volume/count) and the company's preferredUnitSystem setting (imperial/metric/both). Backend endpoint GET `/api/units/compatible?unitId=<uuid>` returns filtered units. Frontend uses React Query with custom queryFn to fetch compatible units, implementing length-aware fallback `(compatibleUnits?.length ? compatibleUnits : allUnits)` to ensure dropdown always has options.
- Recipe Cost Caching: Recipes list displays real-time calculated costs instead of stale database values. GET /api/recipes endpoint calculates costs on-demand using bulk-loaded data with parallel processing and per-request memoization. Calculated costs overwrite the `computedCost` field in API responses. A 5-minute cache (`recipes:costs:${companyId}`) optimizes performance. Cache invalidation via `cacheInvalidator.invalidateRecipes()` ensures the cache is cleared when recipes, recipe components, or inventory prices changes.
- Order Completion Timestamps: Orders page displays completion timestamps via mouseover tooltips on status badges. For transfer orders with `status="completed"`, tooltip shows `transferOrder.completedAt`. For purchase orders with `status="received"`, tooltip shows the latest completed receipt's `receivedAt` timestamp. Only orders with `status="completed"` or "received" AND a valid completedAt value show the tooltip.
- Date Formatting & Timezone Safety: All date displays use `formatDateString()` helper that parses YYYY-MM-DD strings into local timezone Date objects. Purchase order Expected Date field uses standard HTML `<input type="date">`. Date flow is entirely string-based: backend sends YYYY-MM-DD, frontend stores/edits as string, display converts to local timezone only.
- Receiving Page Status Display: Consolidated duplicate status badges into single Badge component with conditional styling. Shows green "received" badge when receipt is completed OR purchase order status is "received".
- Transfer Order Usage Tracking: Usage calculation on Purchase Order detail page now accounts for outbound transfers to prevent over-ordering. Formula updated to: Usage = Previous Count + Received - Transferred - Current. New "Transfers" column displays between "Current" and "Usage" and "Usage" columns, showing quantities transferred out during the count period. Multi-tenant data isolation enforced with comprehensive validation.
- Conditional Transfer UI Rendering: Transfer-related features are automatically hidden for single-store companies (transfers require minimum 2 stores). Sidebar's "Transfer Orders" menu item is conditionally rendered based on accessible stores count. Purchase Order detail page's "Transfers" column is conditionally rendered using the same logic.
- Tare Weight Categories & Case Counting: Categories table includes `isTareWeightCategory` field (integer 0/1, default 0) to identify categories that enable case counting in inventory counts. Storage Locations table includes `allowCaseCounting` field (integer 0/1, default 0) to enable case count fields for items in specific locations. Both fields appear as checkboxes in their respective management UIs.
- Inventory Count Smooth Scrolling Anchors: Category and location filter cards implement smooth scrolling to corresponding accordion sections. `generateAnchorId()` helper creates URL-safe IDs. `scrollToSection()` waits 300ms for accordion expansion before scrolling, respects `prefers-reduced-motion` accessibility preference, and focuses trigger elements for keyboard navigation. Accordion uses controlled state that resets when groupBy mode changes.
- Inventory Count Layout Optimization: Accordion headers show simplified layout (group name + total value only, item count hidden on mobile). Location value rows within category view use CSS grid layout (160px label, flexible input, 100px right-aligned value column) for clean alignment. Previous count value moved to dedicated footer section. Alternating row striping (bg-muted/20 opacity) applied to location input rows.
- Inventory Count Text Search: Count session page includes text search input that filters items by name or PLU/SKU (case-insensitive). Search integrates seamlessly with existing grouping modes and other filters. "Clear Filters" button clears search along with other active filters. Empty accordion groups are automatically hidden when search filters out all items.
- TFC Theoretical Usage Detail: TFC Variance Report features clickable theoretical usage values that open a detailed breakdown modal. Dialog displays summary cards (Total Quantity, Total Cost, Menu Items count) and a Menu Item Breakdown table showing which menu items contributed to theoretical usage. Backend endpoint `/api/tfc/variance/theoretical-detail` aggregates stored theoretical_usage_lines data across multiple runs within the count period, distributing usage proportionally based on menu item quantities sold. Data is fetched lazily via React Query only when dialog opens, with per-item caching for performance.
- TFC Purchase Order Display: Purchase orders delivered during the count period are displayed as "M/D/YY - Vendor Name" format with multiple orders separated by "|" characters. Backend fetches vendor data and includes vendor names in the purchase order response. Frontend formats dates as single-digit month and day with 2-digit year.
- TFC Unit System Clarification: The `theoretical_usage_lines.requiredQtyBaseUnit` field stores quantities in each inventory item's unit (e.g., pounds for cheese, fluid ounces for liquids), NOT in micro-units. The term "base unit" refers to the inventory item's base unit, not the system's canonical base (grams/mL). Both actual usage (from inventory counts) and theoretical usage (from stored theoretical usage runs) are already in the same inventory-item-level units, requiring no conversion in variance calculations. The `units.toBaseRatio` field converts to canonical base units (grams/mL) and should NOT be used for variance comparisons. Recipe component calculations use `convertToBaseUnit()` to ensure recipe ingredients are converted into the target inventory item's unit before storage. The variance endpoint queries stored `theoretical_usage_lines` (which already have unit conversions applied) rather than recalculating from recipe components to ensure consistency with the theoretical detail modal.
- TFC Variance Cost Calculation: Variance cost impact is calculated as (variance units × weighted average cost per unit). The `getItemUsageBetweenCounts` function returns `pricePerUnit` populated from `inventory_items.avgCostPerUnit` (weighted average average cost) for accurate cost calculations. Variance cost = (actualUsage - theoreticalUsage) × pricePerUnit.
- TFC Variance Table Enhancements: Variance report includes WAC (Weighted Average Cost) column positioned between Variance % and Cost Impact, displaying the per-unit cost used in variance calculations. Table includes totals row at bottom showing sum of all variance costs with color-coded display (red for over-usage, green for savings) and bold styling with muted background.
- TFC Purchase Order Receipt Modal: Purchase orders displayed in the "Purchase Orders Delivered" section are clickable, opening a modal dialog that shows receipt details without leaving the variance page. Modal displays received items with quantities, prices, and line totals, along with receipt status and timestamp. Includes "View Full Order" button to navigate to the complete purchase order page. Backend endpoint `/api/purchase-orders/:poId/receipts` nourishes receipt lines with inventory item names, vendor SKUs, and unit names for complete display.
- TFC Variance Summary Cards: Variance page displays inventory count periods as a grid of clickable summary cards insteads of a dropdown selector. Each card shows: Inventory Date, Inventory Value (total count value), Total Sales (POS sales for the period), Total Variance $ and % (aggregated across all items). Cards use responsive layout (1/2/3 columns on mobile/tablet/desktop) with hover elevation and selected state styling (border-primary bg-accent). Backend endpoint `/api/tfc/variance/summaries?storeId=X` calculates and returns summaries for all count periods. Frontend auto-selects the most recent period on load and clears selection when store changes to prevent stale count ID/store ID mismatches. Provides immediate visual overview of variance trends across multiple periods.
- QuickBooks Online Integration: OAuth 2.0 integration for pushing received purchase orders as bills. Multi-tenant architecture supports both company-level and store-level QB connections with store-level connections overriding company-level. Backend includes three tables: `quickbooks_connections` (OAuth tokens with company/store isolation), `quickbooks_vendor_mappings` (maps FoodCost Pro vendors to QB vendors), `quickbooks_sync_logs` (tracks sync status with retry logic). OAuth flow uses HMAC-SHA256 signed state parameters to prevent tampering and replay attacks (1-hour expiry). All routes include multi-tenant security validation (store ownership verification). Storage interface provides complete CRUD operations for connections, mappings, and sync logs. Environment variables required: QUICKBOOKS_CLIENT_ID, QUICKBOOKS_CLIENT_SECRET, QUICKBOOKS_ENVIRONMENT. Future work: encrypt access/refresh tokens at rest, implement bill-pushing logic on purchase order receipt completion, create frontend UI for QB settings/vendor mapping/sync monitoring.

# System Architecture

- **Frontend**: React 18 (TypeScript, Vite) with `shadcn/ui` (Radix UI, Tailwind CSS), TanStack Query, React Context, and Wouter for routing.
- **Backend**: Node.js (TypeScript) with Express.js and Zod for schema validation.
- **Database**: PostgreSQL, managed with Drizzle ORM.
- **Application Structure**: Multi-tenant Single Page Application (SPA) with strict data isolation.
- **UI/UX Decisions**: Compact navigation, mobile-friendly design, intuitive Recipe Builder with real-time cost visualization, sortable tables, touch-friendly interfaces, theme toggling, conditional UI rendering, and optimized inventory count layouts.
- **Technical Implementations**: Micro-unit system, pluggable adapter pattern for vendor integrations, centralized order management, HMAC-SHA256 security, connection pooling, composite indexes, atomic transactions, Redis caching, and response compression.
- **Feature Specifications**: Dual Inventory Pricing (Last Cost, WAC), Vendor Price Comparison and specific PO pricing, configurable Vendor Delivery Scheduling, Vendor Deletion Constraints, Default Categories, Unit Compatibility Filtering in Recipe Builder, 5-minute Recipe Cost Caching with invalidation, Order Completion Timestamps, YYYY-MM-DD Date Formatting with local timezone display, Consolidated Badge component for Receiving Status, Transfer Order Usage Tracking with conditional UI, Tare Weight/Case Counting via category/location flags, Inventory Count Smooth Scrolling Anchors, Inventory Count Text Search, TFC Theoretical Usage Detail modal, formatted TFC Purchase Order Display, TFC Unit System (item's base unit), TFC Variance Cost Calculation using WAC, TFC Variance Table with WAC column and color-coded totals, TFC Purchase Order Receipt Modal, TFC Variance Summary Cards, and QuickBooks Online Integration.

# External Dependencies

- **Database Services**: Neon serverless PostgreSQL.
- **Real-time Communication**: `ws` library for WebSockets.
- **Image Processing**: Sharp.
- **Object Storage**: Replit's native object storage.
- **Vendor Integrations**: Custom adapters for Sysco, GFS, and US Foods.
- **QuickBooks Online Integration**: OAuth 2.0 integration via `intuit-oauth` package.