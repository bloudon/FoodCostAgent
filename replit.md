# Overview

This project is an inventory management and recipe costing system designed to enhance profitability and operational efficiency for food service businesses. It provides precise unit conversions, comprehensive nested recipe management, integration with POS sales data, and detailed variance reporting. The system aims to offer data-driven insights for strategic decision-making, positioning itself as a leading solution for optimizing food costs and streamlining operations.

# User Preferences

- Preferred communication style: Simple, everyday language.
- Default Unit of Measure for Inventory Items: Pound should be the default unit when creating new inventory items.
- Unit Abbreviation: "Pound" displays as "lb." throughout the UI.
- Yield Field: Yield is stored as a percentage value (0-100).
- Par Level & Reorder Level: Stored on `inventory_items` table as default values, overrideable at the store level.
- Active/Inactive Status: Dual-level active status (global and store-specific).
- Store Locations: Inventory items require assignment to at least one store location during creation.
- Storage Locations: Inventory items can be associated with multiple storage locations; at least one is required. Storage Locations page features drag-and-drop reordering. Inventory count displays respect storage location sortOrder.
- Recipe `canBeIngredient`: Recipes include a `canBeIngredient` checkbox field (0/1 in DB) to mark if they can be used as ingredients in other recipes.
- Category Filtering in Recipe Builder: Categories include a `showAsIngredient` field (0/1 in DB) controlling whether items in this category appear in the recipe builder's ingredient selection.
- Recipe Cost Calculation Fix: Ingredient prices must be converted to base unit prices before multiplication.
- Recipe Company Isolation: Implement comprehensive company-level isolation for recipes and recipe components.
- Recipe Cost Recalculation on Inventory Price Changes: Automatically recalculate all affected recipes when an inventory item's price changes, including nested recipes, ensuring recalculation in dependency order.
- Number Input Fields: All number input fields throughout the application have spinner controls (up/down arrows) removed.
- Recipe Name Capitalization: Recipe names are automatically displayed with the first letter capitalized in all UI presentations while preserving the original database values.
- Placeholder Recipe System: During CSV menu import onboarding, placeholder recipes are automatically created for all recipe items (isRecipeItem=1), containing 1 oz of a "Placeholder Ingredient" and flagged with `isPlaceholder=1`. Menu Items page displays recipe status badges (Placeholder/Complete/Needs Recipe/N/A). Recipe saves set `isPlaceholder` to 0, converting placeholders to complete recipes. Recipe saves trigger Menu Items page refresh to ensure badge status and recipe costs update immediately.
- Menu Item Management: Menu items can be created manually via "Add Menu Item" dialog with form validation (required: name, PLU/SKU; optional: department, category, size, price, recipe, isRecipeItem flag). Recipe selection dropdown allows linking recipes during creation or editing. "Create new recipe with this name" link navigates to Recipe Builder with menu item name pre-populated. Menu items can be edited by clicking the item name or via the actions dropdown menu. Edit dialog includes all fields plus price and recipe selection. Active/inactive status toggle via dropdown actions menu. Department, category, and type filters (Recipe Item/Non-Recipe Item/All) enable easy sorting and filtering. Table displays Recipe Cost (computed from recipe) and Price columns, with Status and Type columns removed for cleaner UI. SKU cleanup script automatically removes pipe symbols from imported POS data and generates abbreviated SKUs (max 10 characters) from item names, with sequential numbering for duplicates.
- Menu Item Store Assignment: Menu items require assignment to at least one store during creation and editing, matching inventory items pattern. Store checkboxes appear in both Add and Edit dialogs with validation.
- Recipe Cost Display: Menu Items page displays computed recipe costs for all menu items that have recipes assigned, including both placeholder and complete recipes. Items without recipes show "-" in the Recipe Cost column.
- Dual Pricing Model: Inventory items track both Last Cost (pricePerUnit - most recent purchase price) and Weighted Average Cost (avgCostPerUnit - WAC calculated across all receipts). Inventory Items page displays both price columns. WAC is calculated during receiving using company-wide quantities: `((totalCompanyQty * currentAvgCost) + (receivedQty * received * receivedPrice)) / (totalCompanyQty + qty))`.
- Vendor Price Comparison: Purchase order creation includes a "Compare Prices" button (TrendingDown icon) on each item row that opens a dialog showing all vendor prices for an item. The dialog displays vendor name, SKU, case size, unit price, and case price, sorted by case price (lowest first). The lowest-priced vendor is highlighted with a "Best Price" badge. Uses vendor-specific case sizes and includes zero-priced items (promotional offers). Only excludes vendors with null/undefined prices.
- Vendor-Specific Purchase Order Pricing: Purchase orders use vendor-specific pricing (vendor_items.lastPrice) instead of general inventory pricing (inventory_items.pricePerUnit). All pricing logic uses nullish coalescing (`??`) to preserve legitimate zero-priced vendor items while falling back to inventory pricing only when vendor prices are null/undefined.
- Vendor Delivery Scheduling: Delivery scheduling is managed at the vendor level. Each vendor has `deliveryDays` (array of weekdays when vendor delivers) and `leadDaysAhead` (number of days before delivery that orders must be placed). Vendors page includes checkboxes for each weekday and a numeric input for lead days ahead in the add/edit vendor dialog. Lead time field has been completely removed from vendor items.
- Vendor Deletion Constraints: Vendors with purchase orders or vendor items (products) cannot be deleted - only deactivated. Backend enforces constraints returning 400 errors with guidance to deactivate instead. Frontend displays error messages via toast notifications.
- Misc Grocery Vendor Protection: "Misc Grocery" is a system vendor automatically created for each company. Frontend hides delete button for vendors with names containing "misc grocery" (case-insensitive). Backend additionally blocks deletion attempts via API.
- Vendor Compliance Fields: Vendors table includes compliance and accounting fields to support expense gateway functionality when products are received. Fields include: `active` (integer 0/1, default 1) for vendor status, `taxId` (text) for Tax ID/EIN, `requires1099` (integer 0/1, default 0) for 1099 reporting requirements, `paymentTerms` (text) for payment terms (e.g., "Net 30", "COD"), `creditLimit` (real) for maximum credit limit, and `certifications` (text array) for vendor certifications (e.g., Organic, Kosher, Halal). Vendors page add/edit dialog includes "Compliance & Accounting" section with all fields. QuickBooks vendor mapping automatically filters to show only active vendors (active = 1).
- Vendor Order Guide CSV Import: Vendors page includes "Import Order Guide" button that opens a dialog for uploading CSV order guides from Sysco, US Foods, or GFS. Smart matching engine uses fuzzy string similarity (levenshtein distance) to match vendor products to existing inventory items, scoring confidence 0-100. Auto-match threshold is 85+ (high confidence), 60-84 requires review (medium confidence), <60 creates new items. Order guide review page displays three groups: auto-matched (green badges, immediate approval), needs review (yellow badges, manual linking or creation), and new items (blue badges, creates inventory + vendor items). Approval workflow creates vendor_items for matched products with current pricing from CSV, auto-creates inventory items for new products with smart defaults (category detection, unit mapping, dual pricing initialization). Backend tables: `order_guides` (tracks upload metadata, status, vendor), `order_guide_lines` (staged products with match status/confidence/linked IDs). API endpoints: POST `/api/order-guides/upload` (parse & match), GET `/api/order-guides/:id/review` (retrieve staging), POST `/api/order-guides/:id/approve` (finalize import). Vendor detection auto-identifies Sysco/GFS/US Foods from vendor name for format-specific CSV parsing.
- Default Categories: All companies automatically start with three default categories: "Frozen", "Walk-In", and "Dry/Pantry". Companies can customize and add additional categories as needed.
- Comprehensive Kitchen Units: System includes 40 comprehensive kitchen measurement units covering both imperial and metric systems. Companies have a `preferredUnitSystem` setting (imperial/metric/both) to control default unit display preferences.
- Unit Compatibility Filtering: Recipe builder implements intelligent unit filtering to prevent incompatible unit selections. When adding or editing ingredients, the unit dropdown automatically filters to show only units matching the ingredient's measurement kind (weight/volume/count) and the company's preferredUnitSystem setting (imperial/metric/both). Backend endpoint GET `/api/units/compatible?unitId=<uuid>` returns filtered units. Frontend uses React Query with custom queryFn to fetch compatible units, implementing length-aware fallback `(compatibleUnits?.length ? compatibleUnits : allUnits)` to ensure dropdown always has options.
- Recipe Cost Caching: Recipes list displays real-time calculated costs instead of stale database values. GET /api/recipes endpoint calculates costs on-demand using bulk-loaded data with parallel processing and per-request memoization. Calculated costs overwrite the `computedCost` field in API responses. A 5-minute cache (`recipes:costs:${companyId}`) optimizes performance. Cache invalidation via `cacheInvalidator.invalidateRecipes()` ensures the cache is cleared when recipes, recipe components, or inventory prices changes.
- Order Completion Timestamps: Orders page displays completion timestamps via mouseover tooltips on status badges. For transfer orders with `status="completed"`, tooltip shows `transferOrder.completedAt`. For purchase orders with `status="received"`, tooltip shows the latest completed receipt's `receivedAt` timestamp. Only orders with `status="completed"` or "received" AND a valid completedAt value show the tooltip.
- Date Formatting & Timezone Safety: All date displays use `formatDateString()` helper that parses YYYY-MM-DD strings into local timezone Date objects. Purchase order Expected Date field uses standard HTML `<input type="date">`. Date flow is entirely string-based: backend sends YYYY-MM-MM, frontend stores/edits as string, display converts to local timezone only.
- Receiving Page Status Display: Consolidated duplicate status badges into single Badge component with conditional styling. Shows green "received" badge when receipt is completed OR purchase order status is "received`.
- Transfer Order Usage Tracking: Usage calculation on Purchase Order detail page now accounts for outbound transfers to prevent over-ordering. Formula updated to: Usage = Previous Count + Received - Transferred - Current. New "Transfers" column displays between "Current" and "Usage" and "Usage" columns, showing quantities transferred out during the count period. Multi-tenant data isolation enforced with comprehensive validation.
- Conditional Transfer UI Rendering: Transfer-related features are automatically hidden for single-store companies (transfers require minimum 2 stores). Sidebar's "Transfer Orders" menu item is conditionally rendered based on accessible stores count. Purchase Order detail page's "Transfers" column is conditionally rendered using the same logic.
- Tare Weight Categories & Case Counting: Categories table includes `isTareWeightCategory` field (integer 0/1, default 0) to identify categories that enable case counting in inventory counts. Storage Locations table includes `allowCaseCounting` field (integer 0/1, default 0) to enable case count fields for items in specific locations. Both fields appear as checkboxes in their respective management UIs.
- Inventory Count Smooth Scrolling Anchors: Category and location filter cards implement smooth scrolling to corresponding accordion sections. `generateAnchorId()` helper creates URL-safe IDs. `scrollToSection()` waits 300ms for accordion expansion before scrolling, respects `prefers-reduced-motion` accessibility preference, and focuses trigger elements for keyboard navigation. Accordion uses controlled state that resets when groupBy mode changes.
- Inventory Count Layout Optimization: Accordion headers show simplified layout (group name + total value only, item count hidden on mobile). Location value rows within category view use CSS grid layout (160px label, flexible input, 100px right-aligned value column) for clean alignment. Previous count value moved to dedicated footer section. Alternating row striping (bg-muted/20 opacity) applied to location input rows.
- Inventory Count Text Search: Count session page includes text search input that filters items by name or PLU/SKU (case-insensitive). Search integrates seamlessly with existing grouping modes and other filters. "Clear Filters" button clears search along with other active filters. Empty accordion groups are automatically hidden when search filters out all items.
- Inventory Count Back to Top Button: Count session page displays a floating "Back to Top" button when user scrolls down more than 300px. Button appears as a rounded circle with ArrowUp icon, positioned at bottom-6 right-6 with shadow-lg and z-50 stacking. Listens directly to main element scroll events (handles `overflow-auto` on main container) with fallback to window scroll. Clicking button smoothly scrolls both window and main element to top. Automatically hides when near top of page. Provides easy navigation on long count sessions without requiring manual sampling.
- TFC Theoretical Usage Detail: TFC Variance Report features clickable theoretical usage values that opens a detailed breakdown modal. Dialog displays summary cards (Total Quantity, Total Cost, Menu Items count) and a Menu Item Breakdown table showing which menu items contributed to theoretical usage. Backend endpoint `/api/tfc/variance/theoretical-detail` aggregates stored theoretical_usage_lines data across multiple runs within the count period, distributing usage proportionally based on menu item quantities sold. Data is fetched lazily via React Query only when dialog opens, with per-item caching for performance.
- TFC Purchase Order Display: Purchase orders delivered during the count period are displayed as "M/D/YY - Vendor Name" format with multiple orders separated by "|" characters. Backend fetches vendor data and includes vendor names in the purchase order response. Frontend formats dates as single-digit month and day with 2-digit year.
- TFC Unit System Clarification: The `theoretical_usage_lines.requiredQtyBaseUnit` field stores quantities in each inventory item's unit (e.g., pounds for cheese, fluid ounces for liquids), NOT in micro-units. The term "base unit" refers to the inventory item's base unit, not the system's canonical base (grams/mL). Both actual usage (from inventory counts) and theoretical usage (from stored theoretical usage runs) are already in the same inventory-item-level units, requiring no conversion in variance calculations. The `units.toBaseRatio` field converts to canonical base units (grams/mL) and should NOT be used for variance comparisons. Recipe component calculations use `convertToBaseUnit()` to ensure recipe ingredients are converted into the target inventory item's unit before storage. The variance endpoint queries stored `theoretical_usage_lines` (which already have unit conversions applied) rather than recalculating from recipe components to ensure consistency with the theoretical detail modal.
- TFC Variance Cost Calculation: Variance cost impact is calculated as (variance units × weighted average cost per unit). The `getItemUsageBetweenCounts` function returns `pricePerUnit` populated from `inventory_items.avgCostPerUnit` (weighted average average cost) for accurate cost calculations. Variance cost = (actualUsage - theoreticalUsage) × pricePerUnit.
- TFC Variance Table Enhancements: Variance report includes WAC (Weighted Average Cost) column positioned between Variance % and Cost Impact, displaying the per-unit cost used in variance calculations. Table includes totals row at bottom showing sum of all variance costs with color-coded display (red for over-usage, green for savings) and bold styling with muted background.
- TFC Purchase Order Receipt Modal: Purchase orders displayed in the "Purchase Orders Delivered" section are clickable, opening a modal dialog that shows receipt details without leaving the variance page. Modal displays received items with quantities, prices, and line totals, along with receipt status and timestamp. Includes "View Full Order" button to navigate to the complete purchase order page. Backend endpoint `/api/purchase-orders/:poId/receipts` nourishes receipt lines with inventory item names, vendor SKUs, and unit names for complete display.
- TFC Variance Summary Cards: Variance page displays inventory count periods as a grid of clickable summary cards insteads of a dropdown selector. Each card shows: Inventory Date, Inventory Value (total count value), Total Sales (POS sales for the period), Total Variance $ and % (aggregated across all items). Cards use responsive layout (1/2/3 columns on mobile/tablet/desktop) with hover elevation and selected state styling (border-primary bg-accent). Backend endpoint GET `/api/tfc/variance/summaries?storeId=X` calculates and returns summaries for all count periods. Frontend auto-selects the most recent period on load and clears selection when store changes to prevent stale count ID/store ID mismatches. Provides immediate visual overview of variance trends across multiple periods.
- Dashboard Stat Cards: Dashboard displays four clickable stat cards providing quick navigation to key pages. Cards show: Active Items (links to /inventory), Recent Variance (links to /variance with color-coded red/green for losses/savings), Inventory Counts (links to /inventory-sessions), and Menu Items (links to /menu-items showing total active menu items at the selected store). Recent Variance card replaced the previous "Inventory Value" stat and displays most recent week's variance with date. Menu Items card replaced "Recent Orders" stat since detailed order information is already shown in the Recent Orders table below the stat cards.
- Dashboard Actual Received Values: Recent Orders section on Dashboard displays actual received values from completed receipts instead of expected order totals for received purchase orders. Backend `/api/receipts` endpoint enriched to calculate and include `totalAmount` field (sum of receivedQty × priceEach from receipt lines) for each receipt. Frontend creates receipt lookup map by purchase order ID and displays actual total when completed receipts exist, falling back to expected totalAmount for non-received orders.
- Dashboard Pending Order Deadlines: Dashboard displays a prominent header section showing pending purchase orders with upcoming deadlines based on vendor delivery schedules. Backend endpoint `/api/purchase-orders/deadlines` calculates next delivery dates using vendor `deliveryDays` (searches from today, including same-day deliveries), computes order deadlines as (delivery date - `leadDaysAhead`), and returns urgency flags (isUrgent for deadlines ≤1 day, isPastDue for negative days). Frontend displays up to 5 deadlines with color-coded visual indicators: red for past due, orange for urgent (today/tomorrow), default for normal. Each deadline shows vendor name, internal order ID, deadline date, delivery date, and days until deadline badge. All deadlines are clickable links to purchase order detail pages. "View all" button appears when >5 pending orders exists. Header conditionally renders only when deadlines exists.
- Dashboard Recent Orders Mixed Display: Dashboard "Recent Orders" section displays both purchase and transfer orders combined, sorted by creation date (most recent first), showing the last 3 orders. Transfer orders are fetched via `/api/transfer-orders` and filtered by selected store (matching either fromStoreId or toStoreId). Combined orders include a type field ('purchase' | 'transfer') for conditional rendering. Transfer orders display "FromStore → ToStore" format instead of vendor names, are labeled as "Transfer #{id}", and link to `/transfer-orders/{id}`. Purchase orders display vendor names, are labeled as "Purchase #{id}", show dollar amounts (actual received or expected total), and link to `/purchase-orders/{id}` (pending) or `/receiving/{id}` (received/completed). All orders display color-coded status badges consistent with Orders page styling.
- Dashboard Inventory Value Display: Dashboard "Recent Inventory" section displays a single clickable line showing the most recent inventory count with large value display (text-2xl), date, and item count. When 2+ historical counts exist, displays average inventory value calculated across all counts at the selected store with color-coded comparison badge (green for below average, red for above). Backend endpoint GET `/api/inventory-count-lines?storeId={id}` returns aggregated count lines for average calculation with multi-tenant security validation (global admins can access any store, company users restricted to their own stores). Frontend query uses React Query with conditional enable guard to prevent premature API calls before store selection.
- Transfer Orders Clickable Links: Transfer Orders list page displays Transfer IDs as visually obvious clickable links styled with primary color (`text-primary hover:underline cursor-pointer font-medium`) instead of ghost buttons. Clicking a Transfer ID navigates to `/transfer-orders/{id}` detail page for viewing/editing the transfer order.
- Transfer Order Item Filtering: Transfer order detail page implements status-based item filtering to provide clean, focused views. When status is "pending" (edit mode), all inventory items are displayed so users can add/remove items from the transfer. When status is "in_transit" or "completed" (receive/view mode), only items with quantity > 0 are displayed, eliminating clutter from empty rows. Total value calculation reflects only displayed items. This ensures receiving pages show only the items actually being transferred.
- Order Status Color-Coded Badges: Both Orders page and Dashboard Recent Orders section display vibrant color-coded status badges: yellow/pending, blue/ordered, purple/in_transit, green/received and completed. Status badges use consistent styling across all pages with background/text/border color coordination for clear visual status identification.
- QuickBooks Online Integration: Fully functional OAuth 2.0 integration completed. Multi-tenant architecture supports both company-level and store-level QB connections with store-level connections overriding company-level. Backend includes four tables: `quickbooks_connections` (OAuth tokens with company/store isolation), `quickbooks_vendor_mappings` (maps FnBcostpro vendors to QB vendors), `quickbooks_sync_logs` (tracks sync status with retry logic), `quickbooks_token_logs` (structured logging for token refresh events with success/failure tracking). OAuth flow uses HMAC-SHA256 signed state parameters to prevent tampering and replay attacks and automatic redirect URI construction. All routes include multi-tenant security validation. Storage interface provides complete CRUD operations for connections, mappings, sync logs, and token logs. Settings → Integrations tab displays connection status, expiry dates, connection level (company-wide vs store-specific), and disconnect functionality. Production-ready token auto-refresh infrastructure includes: `refreshTokenIfNeeded()` with 5-minute buffer, structured logging, `refreshAllActiveConnections()` utility, hourly scheduled background job, feature-flag guard, and admin-triggered manual refresh endpoint.
- QuickBooks Selective Vendor Import: Opt-in vendor synchronization workflow allows users to preview and select which QB vendors to import. "Sync Vendors from QuickBooks" button opens preview dialog showing all QB vendors with intelligent match detection (already synced, exact match, possible match, new vendor). Color-coded status badges indicate sync state. Users select vendors via checkboxes with "Select All" functionality for new vendors and exact matches. Already-synced vendors and possible matches are read-only to prevent conflicts. Backend endpoints: GET `/api/quickbooks/vendors/preview` returns preview with match detection, POST `/api/quickbooks/vendors/sync` accepts selectedVendorIds array for selective import. Vendors schema includes QB sync fields: qbVendorId (QB vendor ID), sourceOfTruth (manual/quickbooks), lastSyncAt (last sync timestamp), syncStatus (success/failed/pending). Import process creates new vendors for unmatched QB vendors, links exact matches via vendor mappings, and updates QB-managed vendors with latest data. QuickBooks is source of truth for core fields (name, tax ID, payment terms), FnBcostpro retains restaurant-specific fields (deliveryDays, leadDaysAhead, certifications), but FnBcostpro is the source of truth for all of these fields.
- Estimated On-Hand Inventory: Inventory Items page displays an "Est. On-Hand" column showing real-time estimated current inventory based on last physical count plus activity since then. Calculation formula: Estimated On-Hand = Last Count + Purchases Since Count - Waste Since Count - Theoretical Usage Since Count - Transfers Out. Backend storage function `getEstimatedOnHand(companyId, storeId)` aggregates all inventory movements since the most recent count with strict multi-tenant data isolation (all queries filter by both companyId and storeId). Backend endpoint GET `/api/inventory-items/estimated-on-hand?storeId={id}` validates store ownership before returning data and is positioned BEFORE the `:id` parameterized route to prevent route collision. Frontend displays estimated values in blue text (text-blue-600 dark:text-blue-400) in dedicated column positioned after "Quantity". Shows "—" placeholder when no inventory count exists for the selected store. Query only enabled when a specific store is selected (not "all"). Real-time updates: Estimated on-hand cache is automatically invalidated when waste is logged, receipts are completed, inventory counts are applied, transfers are executed/received, or sales CSV files are uploaded (triggering theoretical usage calculations), ensuring values stay current. Helps identify discrepancies between expected and actual inventory levels without requiring a full physical count.
- Sales CSV Date Parsing: CSV upload date parsing fixed to prevent timezone-induced date shift bug. Sales dates in YYYY-MM-DD format are now parsed as local timezone dates (using explicit year/month/day components) instead of UTC, ensuring CSV dates like "2025-11-21" are posted as 2025-11-21 rather than shifting to the previous day. Fix applied in server/routes.ts line 6221-6223.
- Sales CSV Upload Cache Invalidation: Frontend cache for estimated on-hand inventory is now automatically invalidated after CSV sales uploads complete (client/src/pages/tfc-sales-import.tsx line 173). This ensures theoretical usage calculations immediately reduce estimated on-hand values without requiring manual page refresh. Note: Sales on the SAME DAY as an inventory count are excluded from estimated on-hand calculations (they were part of what was counted) - only sales from days AFTER the count date reduce inventory estimates.

# System Architecture

- **Frontend**: React 18 (TypeScript, Vite) SPA utilizing `shadcn/ui` (Radix UI, Tailwind CSS), TanStack Query, React Context, and Wouter for routing. Designed with a mobile-first approach.
- **Backend**: Node.js (TypeScript) with Express.js and Zod for data validation.
- **Database**: PostgreSQL, managed by Drizzle ORM, featuring connection pooling, composite indexes, and atomic transactions.
- **Application Structure**: A multi-tenant Single Page Application (SPA) ensuring strict data isolation. It employs micro-unit calculation precision, a pluggable adapter pattern for integration extensibility, centralized order management, secure OAuth (HMAC-SHA256), Redis caching, and response compression.
- **UI/UX Decisions**: Emphasizes mobile-first design, streamlined navigation, an intuitive Recipe Builder with real-time costing, sortable and filterable data tables, theme toggling, optimized inventory count layouts, visual variance reporting, dynamic dashboard with clickable statistics, mixed display for recent orders, consistent color-coded status badges, and conditional UI rendering.
- **Technical Implementations**: Includes comprehensive unit conversion, multi-level nested recipe costing, dual inventory pricing (Last Cost & Weighted Average Cost), robust QuickBooks Online integration (multi-tenancy, selective vendor import, automated token refreshing), and an intelligent vendor order guide import feature with fuzzy matching and approval workflows. Real-time recipe cost calculation is optimized through caching.
- **System Design Choices**: Features strict multi-tenancy with robust data isolation. Utilizes a micro-unit precision system for all inventory and recipe calculations. Incorporates a pluggable integration adapter pattern to ensure future extensibility. Security is paramount, implemented via HMAC-SHA256 for OAuth and extensive server-side data validation.

# External Dependencies

- **Database Services**: Neon serverless PostgreSQL.
- **Real-time Communication**: `ws` library for WebSockets.
- **Image Processing**: Sharp.
- **Object Storage**: Replit's native object storage.
- **Vendor Integrations**: Custom adapters for Sysco, GFS, and US Foods order guides.
- **QuickBooks Online Integration**: `intuit-oauth` package for OAuth 2.0.